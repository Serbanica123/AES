#include <stdio.h>
#include <stdint.h>
#include "xbasic_types.h"
#include "xparameters.h"
#include "sleep.h"
#include "xtime_l.h"

// Define the parameters
#define Kp 100000.0
#define Ki 0.1
#define Kd 0.01
#define sleeptime_ms 1000

// Save addresses from the FPGA Setup
Xuint32 *BASEADDR_ENC = XPAR_AXI_GPIO_0_BASEADDR;
Xuint32 *BASEADDR_PWR = XPAR_AXI_GPIO_1_BASEADDR;

uint32_t currentPosition = 0;
uint32_t previousPosition = 0;
uint32_t controllerOutput = 0;

int main() {
	// Save in and output values in 32bit integers


    // Integral, derivative and proportional error values can be decimals so should be float
    // float integral = 0.0;
    // float derivative = 0.0;
    // float proportional = 0.0;


    while (1) {
        // Read the current value from GPIO
    	currentPosition = *(BASEADDR_ENC);
    	xil_printf("Current position: %d \n\r", currentPosition);

        // Calculate the integral
        //integral += currentPosition * sleeptime_ms/1000; // Use rectangle method to determine integral
        //xil_printf("Integral value: %d \n\r", integral);

        // Calculate the derivative
        //derivative = (currentPosition - previousPosition) / sleeptime_ms/1000; // Determine derivative using Euler formula
        //xil_printf("Derivative value: %d \n\r", derivative);

        // Calculate the error (assuming setpoint is 0 for simplicity)
        // proportional = currentPosition;

        // Calculate the PID output
        controllerOutput = Kp * currentPosition; //+ Ki * integral + Kd * derivative;
        // xil_printf("Output power value: %d \n\r", controllerOutput);

        // Write the power level to the output
        // *(BASEADDR_PWR) = controllerOutput;

        // Update previous values for the next iteration
        previousPosition = (previousPosition+1)*2;
        *(BASEADDR_PWR) = previousPosition;
        xil_printf("Previous Position value: %d \n\r", previousPosition);
        usleep(sleeptime_ms * 1000); // Sleep for sleeptime_ms milliseconds
    }

    return 0;
}
